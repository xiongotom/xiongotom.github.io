(window.webpackJsonp=window.webpackJsonp||[]).push([[14],{147:function(t,e,i){"use strict";i.r(e);var a=i(0),n=Object(a.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var t=this,e=t.$createElement,i=t._self._c||e;return i("div",{staticClass:"content"},[i("h1",{attrs:{id:"unix哲学之分离原则"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#unix哲学之分离原则","aria-hidden":"true"}},[t._v("#")]),t._v(" Unix哲学之分离原则")]),t._v(" "),i("h2",{attrs:{id:"《unix编辑艺术》读书笔记"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#《unix编辑艺术》读书笔记","aria-hidden":"true"}},[t._v("#")]),t._v(" "),i("em",[t._v("《UNIX编辑艺术》读书笔记")])]),t._v(" "),i("h2",{attrs:{id:"【声明】读书笔记包括原文摘抄和个人思考心得，原文一切版权归本书作者所有"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#【声明】读书笔记包括原文摘抄和个人思考心得，原文一切版权归本书作者所有","aria-hidden":"true"}},[t._v("#")]),t._v(" "),i("em",[t._v("【声明】读书笔记包括原文摘抄和个人思考心得，原文一切版权归本书作者所有")])]),t._v(" "),i("blockquote",[i("p",[t._v("策略同机制分离，接口同引擎分离")])]),t._v(" "),i("p",[t._v("正文摘抄:")]),t._v(" "),i("ol",[i("li",[t._v("在Unix之失的讨论中，我们谈到过X系统的设计者在设计中的基本抉择失实行“机制，而不是策略”这种做法 — 使X成为一个通用图形引擎，而将用户界面风格留给工具包合作系统的其他层次来决定。…… 因为策略和机制是按照不同的时间尺度变化的，策略的变化要远远快于机制。GUI工具包的观感时尚来去匆匆，而光栅操作和组合确实永恒的。")]),t._v(" "),i("li",[t._v("实现这种剥离的一个方法是，比如，将应用按照一个库来编写，这个库包含许多由内嵌脚本语言驱动的C服务程序，而至于整个应用的控制流程则用脚本来撰写而不是用C语言。")]),t._v(" "),i("li",[t._v("另一种方法是将应用程序分成可以协作的前端和后端进程……前端实现策略，后端实现机制")])]),t._v(" "),i("p",[t._v("理解及感受：\n单单从字面上去理解策略和机制的分离，多少有点迷糊。策略和机制如何区分，何为策略，何为机制呢？不过这些具体的边界无需深究，这一原则我们也一直有在实践：前后端分离，面向对象等等。\n就我自己的理解来说，Unix遵从“做好一件事”，系统本身就是有一个个的工具组合而成。当工具本身足够小时，这些工具提供的功能集就算是一种机制，具体功能的实现，只需要组合这些工具即可，而组合这些工具，并完成任务的过程，就算策略吧。优点是显而易见的：具体的功能往往各有不同，且经常变化。功能需求的变化无需牵动全身，只需调整组合工具的过程就可以，代价会小很多；另一方面，工具本身的调整和优化，仅需自身的修改即可，不会有多余的副作用。")])])}],!1,null,null,null);n.options.__file="PhilSplit.md";e.default=n.exports}}]);